\chapter{Desarrollo}
\label{cap:Desarrollo}

\setlength{\parindent}{0pt}

En este capítulo se hablará del desarrollo de la aplicación Android (diseño, funcionalidades\dots) que he estado realizando a lo largo del TFG, así como el registro de claves para poder interactuar con la red blockchain que se ha levantado. También, se explicará en que consiste el SDK desarrollado, cuales son sus funcionalidades y como poder utilizarlo para otras aplicaciones Android.

% ##################################################
% ##################################################
\section{Aplicación Android}

Para el desarrollo de la aplicación móvil, se ha decidido enfocarlo únicamente a aplicaciones Android. Lógicamente, en un futuro, se tendrá que adaptar una aplicación para otros sistemas como iOS. O por el contrario reescribir él código con lenguajes ````cross platform'' para permitir el correcto funcionamiento nativo tanto en Android como en iOS, una buena opción es utilizar \textbf{flutter}\cite{flutter}.

% --------------------------------------------------
\subsection{Diseño de la Aplicación}

A la hora de pensar en el diseño completo del proyecto, decidí utilizar un diseño modular soportado por APIs, esto me permite tener múltiples componentes independientes los cuales trabajan juntos. Gracias a esto, cambios en el código de un componente o API, son completamente transparentes para el resto de APIs. El proyecto dispone entonces de 3 APIs. Tenemos, la API que se comunica con la base de datos, la API que se comunica con la red blockchain, y la API que hace de intermediario para que el móvil no tenga que comunicarse con las otras dos APIs centrando así la comunicación. Además, el dispositivo móvil se comunica también con la red blockchain para algunas tareas que expongo en la sección \hyperref[sec:SDK]{SDK}. De estos componentes los que nos interesan para este trabajo son la aplicación Android y la API de microservicios, ambos desarrollados a lo largo del trabajo de fin de grado, la API de la base de datos y la red blockchain fueron desarrolladas con anterioridad al TFG. 

\subsubsection{Arquitectura}
\begin{figure}[h!]
  \centering
  \includegraphics[width=0.6\linewidth]{figs/Desarrollo/Arquitectura}
  \caption[Arquitectura]{Arquitectura Completa del proyecto}
  \label{fig:estublockArch}
\end{figure}

El dispositivo móvil se comunica con la api de microservicios a través de dos librerías que veremos más en profundidad en \hyperref[sec:Codigo]{Codigo} esta a su vez se comunica con la API de la base de datos o de la red blockchain según la operación que se haya especificado y estas se comunican con el servidor postgresql para la base de datos y la red de quorum para la blockchain. Como pequeño apartado, la API que se comunica con el servidor postgresql esta desarrollada con NodeJS y utiliza la librería \emph{node-postgres} y la API que se comunica con quorum también esta desarrollada con NodeJS y utiliza la librería \emph{web3} para comunicarse con la red blockchain. 

% --------------------------------------------------
\subsection{Desarrollo de Microservicio Externo}

El objetivo de desarrollar una API extra con la que centralizar las llamadas a la base de datos y a la red blockchain, es para agilizar las llamadas y tratamiento de datos por parte del dispositivo móvil, así como minimizar la cantidad de código, tamaño de la aplicación móvil, dependencias del proyecto\dots La API de microservicios con la que se comunica la aplicación móvil esta desarrollada utilizando \textbf{NodeJS} y ha sido documentada utilizando \textbf{Swagger} como se puede ver en la siguiente imagen.

\begin{figure}[hbt]
	\centering
	\begin{subfigure}[b]{0.4\linewidth}
		\centering
        \includegraphics[width=0.6\linewidth]{figs/Desarrollo/Swagger}
        \caption[Swagger]{Fragmento de documentación en Swagger del Proyecto}
	\end{subfigure} 
	\begin{subfigure}[b]{0.4\linewidth}
		\centering
        \includegraphics[width=0.6\linewidth]{figs/Desarrollo/SwaggerUsuario}
        \caption[Swagger Usuario]{Fragmento de documentación de crear usuario}
	\end{subfigure} 
	\caption[Swagger]{Documentación con Swagger}
	\label{fig:programas}
\end{figure}

% --------------------------------------------------
\subsubsection{NodeJS}
Node.js\cite{nodejs} es un entorno de ejecución de \textbf{JavaScript} construido con el motor de \emph{JavaScript V8 de Chrome}. Esta ideado como un entorno orientado a eventos asíncronos con el que se pueden diseñar aplicaciones escalables en la red. Permite tratar múltiples conexiones simultaneas sin que el programador tenga que preocuparse por la concurrencia. Hoy en día, los modelos de concurrencia usan hilos del sistema operativo y requieren de bloquear procesos para operaciones de lectura y escritura. Los usuarios de NodeJS están libres de preocuparse por el bloqueo del proceso, ya que no existe. De ahí que sea muy propicio desarrollar sistemas escalables con NodeJS, de todos modos aunque NodeJS trabaja sin hilos, se pueden aprovechar múltiples núcleos en su entorno, generando varios procesos. \\

He decidido utilizar NodeJS para desarrollar la API de microservicios pues me da la seguridad de que responderá correctamente a miles de llamadas simultaneas (siempre y cuando el servidor en el que se este ejecutando pueda con el poder de computo que ello requiere). Así pues, puedo estar tranquilo y saber que el sistema no se caerá y podrá dar servicio un largo tiempo. Además, NodeJS junto con su gestor de paquetes \emph{npm} me permiten mantener el sistema actualizado con facilidad sin preocuparme de problemas de dependencias y paquetes desactualizados o que tienen problemas de seguridad. \\

Algunos ejemplos de grandes proyectos que utilizan NodeJS son:
\begin{itemize}
\item Netflix
\item Trello
\item PayPal
\item LinkedIn
\item Uber
\end{itemize}

% --------------------------------------------------
\subsubsection{Swagger}
A la hora de programar una API, no es solo importante que el código sea correcto y funcione correcta y eficientemente. Sino que también es muy importante la documentación de la API, esto permite a otros programadores poder utilizarla sin preocuparse del código, y sin necesidad de conocer el proyecto. Para ello, he utilizado \textbf{Swagger} \cite{swagger}. Swagger es un conjunto de herramientas profesionales y de código abierto las cuales ayudan a diseñar y documentar APIs de forma escalable. Swagger permite hacer varias cosas:
\begin{itemize}
\item Diseñar
\item Desarrollar
\item Documentar
\item Testear
\item Virtualizar
\item Monitorizar
\end{itemize}

Para este proyecto, me aproveche principalmente de las herramientas de diseño, desarrollo y documentación. Centrándome sobre todo en la comodidad de documentación que tiene al utilizar archivos \emph{YAML} (yaml es un formato de serialización de datos legibles por humanos) para generar una documentación ligera, fácil de entender y muy detallada. 

% --------------------------------------------------
\subsubsection{Funcionalidades de la API de Microservicios}
Las funcionalidades de la API se pueden dividir en los siguientes 3 casos de uso generales:

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.6\linewidth]{figs/Desarrollo/UML}
  \caption[Arquitectura]{Los tres casos de uso general de la aplicación}
  \label{fig:casosUso}
\end{figure}

Siendo más concretos pasemos a listar todas las funcionalidades de las que dispone la API, lógicamente esta no es la documentación completa la cual trae consigo los objetos JSON que aceptan la URIs y los errores u objetos JSON que devuelve cada una de las URIs. En el presente la documentación se mantiene en un repositorio de \emph{gitlab} privado. \\

\begin{itemize}
\item \textcolor{green}{{\footnotesize POST} /user:} Permite registrar a un usuario en la base de datos.
\item \textcolor{blue}{{\footnotesize GET} /user/{address}/attendance:} Permite obtener los eventos a los que ha asistido un usuario.
\item \textcolor{blue}{{\footnotesize GET} /user/{email}/subscription:} Permite obtener los temas a los que está suscrito un usuario.
\item \textcolor{green}{{\footnotesize POST} /login:} Permite iniciar sesión (se comprueba que el usuario exista y se comprueba la contraseña hasheada).
\item \textcolor{green}{{\footnotesize POST} /logout:} Permite detectar que un usuario ha cerrado sesión.
\item \textcolor{green}{{\footnotesize POST} /subscription:} Permite a un usuario suscribirse a un tema.
\item \textcolor{red}{{\footnotesize DELETE} /subscription:} Permite a un usuario desabonar su suscripción de un tema.
\item \textcolor{blue}{{\footnotesize GET} /topic:} Permite obtener la lista de temas disponibles.
\item \textcolor{blue}{{\footnotesize GET} /topic/{id}/event:} Permite obtener un listado de los eventos de un tema concreto.
\item \textcolor{blue}{{\footnotesize GET} /topic/{id}/subscription:} Permite obtener un listado con las suscripciones de un tema.
\item \textcolor{green}{{\footnotesize POST} /event:} Permite obtener los datos de la transacción de crear un evento, esta es firmada por el usuario a través de la aplicación Móvil y después enviada a la red blockchain. 
\item \textcolor{blue}{{\footnotesize GET} /event/{id}:} Permite obtener los datos de un evento.
\item \textcolor{orange}{{\footnotesize PUT} /event/{id}:} Permite obtener los datos de la transacción para modificar un evento, también se firma y envía desde el móvil a la red blockchain. 
\item \textcolor{blue}{{\footnotesize GET} /event/{id}/delete/{organizer}:} Permite obtener los parámetros de la transacción para cerrar un evento, se firma y envía desde el móvil.
\item \textcolor{blue}{{\footnotesize GET} /eventCatalog:} Permite obtiene un listado con los tipos de eventos. 
\item \textcolor{green}{{\footnotesize POST} /event/{id}/validator:} Permite añadir a un nuevo validador a un evento.
\item \textcolor{blue}{{\footnotesize GET} /event/{id}/validator/{organizer}:} Permite obtener un listado con los validadores de un evento. 
\item \textcolor{orange}{{\footnotesize POST} /event/{id}/attendance:} Permite obtener los parámetros de la transacción para registrar la asistencia a un evento, igual que antes, se firma y envía desde el móvil. 
\item \textcolor{blue}{{\footnotesize GET} /event/{id}/attendance:} Permite obtener la lista de asistencias a un evento. 
\end{itemize}

Gracias a usar swagger, la API sigue la documentación de forma estricta, es decir, no acepta llamadas en las que no se envien los parámetro especificados en la documentación. Si para crear un usuario se requiere de un campo ``email'', si este campo no existe al hacer la llamada a la API, swagger se encarga de rechazar la llamada con un error de formato. Así logramos evitar que el backend tenga errores por variables indefinidas, nulas, o se guarden datos vacíos\dots

% --------------------------------------------------
\subsection{Interaz de Usuario}

La interfaz de usuario es donde los usuarios interaccionan con tu aplicación. Son las ventanas, botones, pantallas con las que el usuario interacciona. Deben tener un diseño intuitivo, fácil, que brinde una experiencia positiva. A más fácil de entender, mejor. Existen tres grandes tipos de interfaces de usuario, la interfaz de lenguaje natural, es la ideal y el sueño de todo usuario, pues permite comunicar humano y máquina con lenguaje natural. Un ejemplo de dispositivo que utiliza esta interfaz es \emph{Alexa}, que cuenta con un software basado en modelos acústicos y del lenguaje. El segundo tipo de interfaz es la interfaz de preguntas y respuestas. En esta interfaz se muestra una pregunta al usuario y según su respuesta se actúa de una u otra manera. Un ejemplo de estas interfaces son los software de instalación, como puede ser el instalador de un sistema operativo. Y por último, la interfaz que más nos interesa para este proyecto, la \textbf{interfaz gráfica de usuario}, en inglés ``Graphical User Interface'' o \textbf{GUI}. Esta utiliza gráficos, imágenes, videos, iconos, menús\dots para permitir al usuario interaccionar con la aplicación. 

\subsubsection{Diseño de la GUI de Estublock}

A la hora de diseñar la aplicación Estublock, he buscado un diseño ligero, intuitivo y rápido. Como tiene que llegar a muchos usuarios, hay que pensar en posibles problemas de visión, daltonismo, evitar que se pueda mal interpretar un botón, y que el usuario crea que hace una cosa que no hace. Para todo ello, he utilizado una herramienta de diseño para prototipos de pantallas y testeo de pantallas llamado \emph{Marvel}\cite{marvelapp}. Marvel te permite diseñar con bastante detalle aplicaciones móvil y web, y además permite enlazar pantallas para probar la efectividad de las pantallas y el entendimiento de las mismas.

\subsubsection{Interfaces en Android}

En Android la interfaz de usuario se construye mediante una jerarquía de objetos, generalmente de tipo \textbf{View y ViewGroup}. Los \emph{View} son componentes con los que el usuario puede interactuar, el usuario puede ver el componente en la pantalla. Sin embargo los \emph{ViewGroup} son un contenedor invisible que define la estructura de objetos \emph{View} y otros \emph{ViewGroup}.

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.6\linewidth]{figs/Desarrollo/Jerarquia}
  \caption[Android Layout]{Jerarquia de una interfaz de Android}
  \label{fig:interfaz_android}
\end{figure}

Los objetos \emph{View} se denominan ``widgets'' y pueden ser Botones, Textos, ``Switch'', ``ScrollView''\dots. Los objetos \emph{ViewGroup} se denominan ``diseño'' y pueden ser ``LinearLayout'', ``ConstraintLayout''\dots Los diseños se pueden declarar de dos maneras: \\

\begin{itemize}
\item Se pueden declarar elementos de la Interfaz de Usuario en \textbf{XML}
\item Crear una instancia de elementos de diseño durante el tiempo de ejecución.
\end{itemize}

Para la aplicación, he usado ambas formas, pues por un lado hay pantallas estáticas, como pueden ser la pantalla de login o registro. En las que se que botones tiene que haber, que textos tiene que mostrar y que diseño tiene. Pero también hay pantallas en las que se crean botones o texto de forma dinámica dependiendo de el número de temas que haya en la base de datos o según a que temas este suscrita una persona. \\

Gracias a utilizar los archivos XML, puedes separar la presentación de la app del código que controla los componentes, además, facilita la creación de distintos diseños para diferentes tamaños de pantalla y orientación. Es la mejor opción a la hora de crear una GUI aunque en ocasiones se requiera de hacer en tiempo de ejecución. También se puede crear con XML un diseño, y luego modificarlo en tiempo de ejecución según sea necesario. 

% --------------------------------------------------
\subsection{Código} \label{sec:Codigo}

Las aplicaciones Android pueden ser programadas principalmente en dos lenguajes de programación, \textbf{Java} y \textbf{Kotlin}. En el presente, la inmensa mayoría de aplicaciones han sido desarrolladas con Java, sin embargo Kotlin es el futuro, en el presente sigue siendo un lenguaje secundario (aunque se puede hacer todo lo que se puede hacer con Java y esta muy bien documentado) de hecho según google trends, Kotlin esta lejos de quitarle el puesto a Java aunque los nuevos desarrolladores de aplicaciones Android muestran más interés por Kotlin por su comodidad, falta de verbosidad y ``limpieza'' (es decir, con menos líneas de código haces lo mismo que Java). 

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.6\linewidth]{figs/Desarrollo/Popularidad}
  \caption[Java vs Kotlin]{Comparación de Google Trends entre Java y kotlin}
  \label{fig:java_vs_kotlin}
\end{figure}

Por lo tanto, aunque Kotlin promete mucho, he desarrollado la aplicación Estublock en Java. Por suerte, se puede migrar con mucha facilidad a Kotlin puesto que AndroidStudio (el Entodno de Desarrollo Integrado para programar aplicaciones Android) permite migrar automáticamente de Java a Kotlin. Para facilitar este proceso se deben poner ``anotaciones de java'' que especifiquen las características de algunas variables o funciones para facilitar a AndroidStudio el reconocimiento de las variables. Un ejemplo puede encontrarse a continuación donde se puede ver que se especifica que las variables no pueden ser nulas con \emph{@NonNull}.

\begin{lstlisting}[language=Java,float=ht,caption={[Java] Ejemplo de ``anotación de java'' de variables para facilitar el salto a Kotlin},label=lst:java_etiquetas]
public void sendSignedTransaction(@NonNull String signedMessage){
  // Código
}
\end{lstlisting}

% --------------------------------------------------
\subsubsection{Código XML}

Como ya hemos mencionado, las interfaces de usuario en Android se programan utilizando archivos XML. XML del ingles \emph{Extensible Markup Language} es un metalenguaje que permite definir un lenguaje de marcas el cual es utilizado para almacenar datos de forma legible. Permite crear estructuras con parámetros y atributos. A la hora de programar en Android Studio con XML se tienen dos opciones, se puede escribir directamente el código XML o se pude utilizar la herramienta que viene integrada en AndroidStudio con la que se pueden crear elementos y añadirles atributos sin necesidad de programar directamente el XML. 

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.95\linewidth]{figs/Desarrollo/xml_vs_ezpz}
  \caption[XML]{Código XML y su correspondiente en la herramienta de AndroidStudio}
  \label{fig:xml_vs_ezpz}
\end{figure}

Aunque la herramienta de AndroidStudio es muy útil, la mayoría de las pantallas han sido programadas editando el código XML directamente y viendo el resultado en la herramienta de AndroidStudio.

% --------------------------------------------------
\subsubsection{Código Java}

Todo el código de la aplicación esta disponible en mi repositorio de github\cite{forgis98}. Vamos a tratar de resumir el trabajo realizado, pues gran parte de este TFG esta reflejado en la aplicación móvil que se ha desarrollado. \\

\underline{Archivos del Proyecto} \\

El proyecto puede dividirse en 2, el SDK del que hablaremos más adelante. En él esta el código que se comunica con la red blockchain. Y por otro lado están las actividades y fragmentos que se comunican con sus respectivas pantallas, a excepción de un archivo llamando \emph{GlobalState.java}. Este archivo es muy importante, pues sirve para mantener el estado en tiempo de ejecución del proyecto. Guarda información como el nombre de la persona una vez ha hecho login, guarda él directorio de la cartera virtual del usuario, contiene la URL a las APIs de microservicios, red blockchain y demás datos necesarios. \\

A parte de esto, hay una carpeta más, llamada \emph{preferences o shared preferences}. Android proporciona muchas formas de almacenar los datos de una aplicación, y esta es una de ellas. Las preferencias permiten guardar datos en forma de un par \{claves $->$ valor\}. Utilizo este archivo para guardar el correo del usuario asociado con la dirección en la que esta su cartera virtual. Esto permite al usuario tener varias cuentas en el móvil sin que haya conflicto entre las carteras virtuales. \\

\underline{Librerías utilizadas} \\

He utilizado 8 librerías extras (a parte de las que incluye por defecto android al iniciar el proyecto). \emph{web3j} se mencionará en el apartado del \hyperref[sec:SDK]{SDK} y \emph{play-services-vision} es necesaria para \emph{ZXing} pero no la he usado directamente. Queda entonces: \\
\begin{enumerate}
\item \textbf{Volley: } Volley es una biblioteca HTTP que facilita y agiliza el uso de redes en apps para Android. Permite programación automática de solicitudes de res, varias conexiones de red simultáneas, almacenamiento de respuestas en cache\dots He utilizado esta librería para todas las llamadas excepto la llamadas \emph{DELETE} ya que me daba problemas. Algo muy interesante de Volley es que las llamadas son asíncronas, es decir, se ejecutan separadas del hilo principal no bloqueándolo y una vez se recibe la respuesta de la llamada se puede recuperar la información en un callback.

\begin{lstlisting}[language=Java,float=ht,caption={[Java] Ejemplo de llamada POST con Volley.},label=lst:volley]
JsonObjectRequest jsonObjectRequest = new JsonObjectRequest(Request.Method.POST,
    (URL), parametrosJSON,
    new Response.Listener<JSONObject>() {
      @Override
      public void onResponse(JSONObject response) {
        // Hacer algo con respuesta correcta.
      }
    }, new Response.ErrorListener() {
  @Override
  public void onErrorResponse(VolleyError error) {
    // Hacer algo con respuesta error.
  }
});
\end{lstlisting}

Para solventar el problema con la llamada DELETE he usado la siguiente librería.

\item \textbf{Okhttp: } Esta librería cumple la misma función que Volley, permitiendo conexiones HTTP\dots Sin embargo, Volley es asíncrono. Okhttp no lo es, ``obligando'' al programador a hacer las llamadas dentro de un hilo de ejecución nuevo.

\begin{lstlisting}[language=Java,float=ht,caption={[Java] Ejemplo de llamada DELETE con OkHttp.},label=lst:okhttp]
new Thread(new Runnable() {
  @Override
  public void run() {
    try{
      // Hacer cosas dentro del Thread

      okhttp3.RequestBody body = okhttp3.RequestBody.create(
        paramsJSON.toString(), 
        MediaType.parse("application/json; charset=utf-8")
      );

      okhttp3.Request request = new okhttp3.Request.Builder()
        .url(URL)
        .delete(body)
        .build();
      okhttp3.Response response = client.newCall(request).execute();

    } catch(Exception e){
      // Hacer cosas en caso de error.
    }
  }
}).start();
\end{lstlisting}

\item \textbf{Bcrypt: } Es una implementación del algoritmo de hash de contraseñas Blowfish. Básicamente permite cifrar contraseñas para poder guardarlas de forma segura en una base de datos. Con esta librería se cifra la contraseña del usuario que luego se manda a la API para que la guarde en la base de datos.
\begin{lstlisting}[language=Java,float=ht,caption={[Java] Ejemplo de cifrado de la contraseña de un usuario.},label=lst:okhttp]
protected String hashPassword(String password){
  return BCrypt.withDefaults().hashToString(10, password.toCharArray());
}

\end{lstlisting}

\item \textbf{QRGenerator: } Librería para generar códigos QR tanto 1D (códigos de barra) como 2D (QR tradicional) con diferentes formatos.
\begin{lstlisting}[language=Java,float=ht,caption={[Java] Ejemplo de Código QR},label=lst:okhttp]
WindowManager manager = (WindowManager) getSystemService(WINDOW_SERVICE);
Display display = manager.getDefaultDisplay();
Point point = new Point();
display.getSize(point);

qrgEncoder = new QRGEncoder(evento.toString(), null, QRGContents.Type.TEXT, Math.min(point.x, point.y));
bitmap = qrgEncoder.getBitmap();
// qr es el identificador de la interfaz de usuario para poner el QR
qr.setImageBitmap(bitmap);
\end{lstlisting}

\item \textbf{ZXing: } Esta librería permite generar códigos QR, pero más importante y la razón por la que la he usado, permite escanear códigos QR. Para generar QR utilicé la librería anterior puesto que es más fácil de utilizar que ZXing para Android. El código en este caso es bastante más largo por lo que no lo incluyo. Se encuentra de todos modos en el repositorio de github en el archivo \href{https://github.com/FORGIS98/TFG/blob/main/Estublock/app/src/main/java/com/example/estublock/EscanearQRTutorial.java}{EscanearQR.java}.

\end{enumerate}

% ##################################################
% ##################################################
\section{SDK} \label{sec:SDK}

Un \emph{Kit de Desarrollo Software} o SDK (Software Development Kit) es generalmente un conjunto de herramientas de desarrollo de software que permiten a otros desarrolladores crear aplicaciones de forma más cómoda. Un buen ejemplo de SDK que se ha utilizado en este proyecto es la familia de SDKs de Android. Junto con AndroidStudio, se instalan múltiples SDKs que permiten al programador escribir código, recuperar componentes de las pantallas, hacer llamadas a paquetes, importar paquetes, detectar errores\dots Todo de forma automática haciendo que la programación sea mucho más fácil. \\

El SDK es entonces un conjunto de métodos los cuales pueden hacer llamadas a una API, llamadas al propio sistema operativo, llamadas a otras librería o SDKs\dots En el caso del SDK desarrollado para este TFG, su principal función es la de hacer llamadas a una red blockchain y la de hacer llamadas al sistema de archivos del dispositivo para guardar la cartera virtual del usuario. 

% --------------------------------------------------
\subsection{Diseño del SDK}

El SDK dispone de 3 archivos, cada uno con una función concreta. Estos 3 archivos están separados del proyecto Estublock. Para crear la estructura se ha creado un nuevo módulo o librería en AndroidStudio, esto crea una pequeña estructura de carpetas desde la cual crearemos el SDK y posteriormente se pueda publicar en un repositorio público para que otros desarrolladores puedan utilizar la herramienta. Más sobre esto en el capítulo de \hyperref[sec:Maven]{Como Incorporarlo en Otras Aplicaciones}. 

% --------------------------------------------------
\subsection{Comunicación con la Red Blockchain}
En el archivo \emph{TransactionsHelper.java} se encuentra importada la librería de \emph{web3j} y se encuentra también el código que firma y envía las transacciones. Web3j es una biblioteca de Java y Android que permite trabajar con smart contracts e integrarse con clientes o nodos en la red de \emph{Ethereum}. Esto permite trabajar con la red de Ethereum sin necesidad de implementar el código de integración para la plataforma. Implementa la API de cliente JSON-RPC de Ethereum sobre HTTP, soporta carteras virtuales, firmado de transacciones\dots \\

El uso de \emph{TransactionsHelper} es sencillo, primero se crea el objeto pasándole como parámetro la URL del nodo de la red blockchain al que vamos a conectarnos.
\begin{lstlisting}[language=Java,float=ht,caption={[Java] Constructor de TransactionsHelper},label=lst:constructor]
// Constructor
public TransactionsHelper(@NonNull String blockchainURL){
  web3j = Web3j.build(new HttpService(blockchainURL));
}
// Llamada 
TransactionsHelper txHelp = new TransactionsHelper(URL);
\end{lstlisting}

Una vez creado el objeto se puede llamar al resto de funciones, entre las que están \verb|signTransaction(...)| que recibe seis argumentos entre otros las credenciales de la cartera virtual, el destino de la transacción (el smart contract) y un \emph{listener} para recuperar la respuesta de la transacción. Recordemos, no se pueden hacer operaciones pesadas en el hilo principal de Android por lo que hay que hacerlo o en un hilo a parte. Otra función importante es \verb|sendSignedTransaction(...)| la cual recibe dos parámetros, la transacción firmada y un \emph{listener}. Ambas funciones están ``sobrecargadas'' (sobrecarga es la capacidad de un lenguaje de programación, que permite nombrar con el mismo identificador diferentes variables u operaciones), la razón de esta sobrecarga es permitir pasar los parámetro de múltples maneras. Por ejemplo, los datos de la transacción se pueden pasar como JSON, como String, como HashMap\dots y gracias a la sobrecarga podemos ponerle el mismo nombre a la función. A grandes rasgos un pequeño ejemplo de código puede verse a continuación: 

\begin{lstlisting}[language=Java,float=ht,caption={[Java] Firmar y Enviar transacciones.},label=lst:transactionHelper]
// Se crea y firma la transacción
EthGetTransactionCount ethGetTransactionCount = null;
ethGetTransactionCount = web3j.ethGetTransactionCount(credentials.getAddress(), DefaultBlockParameterName.LATEST).send();
BigInteger nonce = ethGetTransactionCount.getTransactionCount();
RawTransaction rawTransaction = RawTransaction.createTransaction(parametrosJSON);
byte [] signedTx = TransactionEncoder.signMessage(rawTransaction, credentials)
signedMessage = Numeric.toHexString(signedTx);

// Se envía la transacción
EthSendTransaction ethSendTransaction = web3j.ethSendRawTransaction(signedMessage).send();
\end{lstlisting}


% --------------------------------------------------
\subsection{Comunicación con el Dispositivo}

Para facilitar la generación de credenciales, cartera virtual, guardar en la carpeta ``Shared Preferences'' de Android todos los datos necesarios para la comunicación con la red blockchain\dots Tenemos el archivo \emph{WalletHelper.java}. En él además de la librería web3j, tenemos algunas funcionalidades de Seguridad de Java para modificar el proveedor de seguridad, y permitir que salten errores por algoritmos o parámetros erróneos. \\

En este archivo tenemos entonces un constructor, el cual modifica el proveedor de seguridad a causa de un error con el algoritmo ``Elliptic Curve Digital Signature Algorithm''(ECDSA)\cite{ecdsa} para el proveedor BC\cite{bc}. Más información sobre el error se puede encontrar en el repositorio de web3j en la \href{https://github.com/web3j/web3j/issues/915}{issue\_915}. Básicamente lo que hace el código es modificar el proveedor.

\begin{lstlisting}[language=Java,float=ht,caption={[Java] Modificación de proveedor de seguridad},label=lst:transactionHelper]
final Provider provider = Security.getProvider(BouncyCastleProvider.PROVIDER_NAME);
if(provider != null || !provider.getClass().equals(BouncyCastleProvider.class)){
  Security.removeProvider(BouncyCastleProvider.PROVIDER_NAME);
  Security.insertProviderAt(new BouncyCastleProvider(), 1);
}
\end{lstlisting}

Luego, el programador dispone de varias funciones para crear una nueva cartera virtual con \verb|createNewWallet(...)| que acepta dos parámetros, siendo estos una contraseña y luego el lugar en el que se quiere guardar la cartera creada. Al igual que antes, esta función esta sobrecargada permitiendo pasar la localización como objeto String o como objeto File. Y permite también recuperar el \emph{address} del usuario o todas las credenciales. 

\begin{lstlisting}[language=Java,float=ht,caption={[Java] Creacion de wallet y recuperación del address},label=lst:transactionHelper]
WalletUtils.generateLightNewWalletFile(password, new File(keyStoreDirectory));

Credentials credentials = WalletUtils.loadCredentials(password, keyStoreDirectory);
String address = credentials.getAddress();
\end{lstlisting}

Como hemos mencionado anteriormente en este archivo se incluye también el guardado de los datos en él dispositivo móvil, aunque la función de web3j \verb|WalletUtils.generateLightNewWalletFile()| guarda los datos en el móvil. Para permitir que un usuario tenga varias carteras, se utiliza el \emph{SharedPreferences} para enlazar al usuario con su wallet. Para ello tenemos la función \verb|saveInPreferences(...)| la cual recibe cuatro parámetros entre ellos el lugar donde guardarlo, y los datos a guardar. Y luego tenemos otro método \verb|getFromPreferences(...)| para recuperar los datos. 

\begin{lstlisting}[language=Java,float=ht,caption={[Java] Guardado y recuperación de dátos en SharedPreferences},label=lst:transactionHelper]
// Guardamos los datos
SharedPreferences sharedPreferences = activity.getSharedPreferences(prefsName, Context.MODE_PRIVATE);
SharedPreferences.Editor editor = sharedPreferences.edit();
editor.putString(id, walletDirectory);
editor.apply();

// Devolvemos el dato con identificador id
return  sharedPreferences.getString(id, null);
\end{lstlisting}

% --------------------------------------------------
\subsection{``Callback Listener''}

Como las llamadas a la red blockchain son pesadas, han sido implementadas con threads: ``\verb|new Threads( new Runnable(){...} )|''. Como el código no espera a la respuesta del thread, he implementado dos funciones que hacen de ``escucha'' para cuando termina la ejecución. Estas funciones están especificadas en \emph{EasyBlockchainListener.java}, este archivo es una \emph{interdaz de java} para poder ser sobrescritas por le programador para que hagan lo que este desee. Utilizando la anotación de java \verb|@Override| con la que se sobrescribe un método para que el programador cambie el código y pueda hacer con la respuesta lo que considere necesario. Tenemos dos callbacks, uno para cuando se firma la transacción, y otro para cuando se envía a la red blockchain. Para utilizarlos no hay más que pasar como último parámetro de las funciones anteriormente mencionadas una función que será la que sobrescriba a los métodos.  

\begin{lstlisting}[language=Java,float=ht,caption={[Java] Ejemplo de sobrescritura de un listener.},label=lst:transactionHelper]
public void doSomething(...){
  signTransaction(credentials, gasPrice, gas, to, data, new EasyBlockchainListener() {
    // Sobrescribimos el método que esta en la interfaz EasyBlockchainListener
    @Override
    public void onSignTransactionEvent(@NonNull @NotNull String signedTx) {
      sendSignedTransaction(signedTx);
    }
  });
}
\end{lstlisting}

% --------------------------------------------------
\subsection{Como Incorporarlo en Otras Aplicaciones} \label{sec:Maven}

Para que otro programador pueda utilizar el SDK que se ha desarrollado el primer paso es publicar el SDK en algún repositorio como en los repositorios de \emph{Maven Centra}\cite{maven}. Maven dispone de una inmensa cantidad de repositorios que usuarios pueden utilizar añadiendo la dependencia a sus proyectos, y gradle (el sistema de automatización de construcción de código que utiliza Android) se encarga de bajar la información automáticamente y así el usuario puede utilizar las funcionalidades que el usuario desea. \\

Para publicar la librería se han de seguir a muy grandes rasgos estos pasos:
\begin{itemize}
\item Crear un ``ticket'' con \emph{Sonatype}\cite{sonatype}.
\item Crear el proyecto en Sonatype.
\item Verificación de propiedad mediante DNS.
\item Instalación del plugin para gradle \href{https://github.com/vanniktech/gradle-maven-publish-plugin}{gradle-maven-publish-plugin}
\item Generar llaves GPG
\item Configurar firmas
\item Subir los artifacts a Sonatype
\item Publicar la librería
\end{itemize}

Más detalles se pueden encontrar en el post de ``Waseef Akhtar''\cite{waseef}. \\

Una vez la librería es pública, cualquier programador puede añadirla a su proyecto añadiendo a sus dependencias la línea \verb|implementation 'com.<entidad>.estublock:EasyBlockchain:1.0.0'|, el nombre de la entidad aún está por definir. Una vez añadida la línea y después de que gradle termine de sincronizar el repositorio, el programador puede utilizar todas las funciones que hayan en la versión 1.0.0 del SDK.


% ##################################################
% ##################################################
\section{Documentación}

La documentación del SDK ha sido generada utilizando \emph{javadocs}, esto permite generar automáticamente una documentación a partir de varios tags de java. Una vez procesados, se genera una sencilla página web en la que se puede consultar la documentación. La documentación actualmente disponible es la siguiente: 

\subsection{TransactionsHelper.java}
\begin{lstlisting}[language=Java,caption={[Java] Documentación de TransactionsHelper},label=lst:transactionHelper]
/**
 * Constructor de la clase.
 * @param blockchainURL La URL y puerto al nodo de la red blockchain con la que se
 * quiere comunicar. 
 */
public TransactionsHelper(@NonNull String blockchainURL);

/**
 * Método que firma una transacción.
 * @param credentials Las credenciales de un usuario, viene a ser su keystore
 * @param gasPrice Cantidad que quieres pagar por unidad de gas como tarifa al minero
 * @param gasLimit Limite máximo que estas dispuesto a pagar por la transacción
 * @param to Address del SMART CONTRACT de destino
 * @param data Información que se va a mandar al smart contract
 * @param listener Callback de la llamada a sobrescribir
 */
public void signTransaction(@NonNull Credentials credentials, @NonNull String gasPrice, @NonNull String gasLimit, @NonNull String to, @NonNull String data, @NonNull EasyBlockchainListener listener);

/**
 * Método que envía una transacción ya firmada con listener.
 * @param signedMessage Transacción firmada lista para ser enviada
 * @param listener Callback de la llamada a sobrescribir
 */
public void sendSignedTransaction(@NonNull String signedMessage, @NonNull EasyBlockchainListener listener);

/**
 * Método que envía una transacción ya firmada sin listener.
 * @param signedMessage Transacción firmada lista para ser enviada
 */
public void sendSignedTransaction(@NonNull String signedMessage);

/**
 * Método que firma y envía una transacción.
 * @param credentials Las credenciales de un usuario, viene a ser su keystore
 * @param gasPrice Cantidad que quieres pagar por unidad de gas como tarifa al minero
 * @param gasLimit Limite máximo que estas dispuesto a pagar por la transacción
 * @param to Address del SMART CONTRACT de destino
 * @param data Información que se va a mandar al smart contract
 * @param listener Callback de la llamada a sobrescribir
 */  
 public void signAndSendTransaction(@NonNull Credentials credentials, @NonNull String gasPrice, @NonNull String gasLimit, @NonNull String to, @NonNull String data);
\end{lstlisting}

\subsection{WalletHelper.java}
\begin{lstlisting}[language=Java,caption={[Java] Documentación de WalletHelper},label=lst:transactionHelper]
/**
 * Constructor de la clase, llama a la función workaroundECDA()
 */
public WalletHelper();

/**
 * Método que arregla el problema con el proveedor de seguridad
 * Para saber más ir a este link: {@link https://github.com/web3j/web3j/issues/915}
 */
private void workaroundECDA();

/**
 * Método que crea una nueva cartera virtual
 * @param password Contraseña de la cartera virtual
 * @param walletDirectory Dirección de la nueva cartera virtual
 */
public String createNewWallet(@NonNull String password, @NonNull File walletDirectory);

/**
 * Método que crea una nueva cartera virtual
 * @param password Contraseña de la cartera virtual
 * @param walletDirectory Dirección de la nueva cartera virtual
 */  @NonNull
public String createNewWallet(@NonNull String password, @NonNull String walletDirectory);

/**
 * Método que devuelve el address de una cartera
 * @param password Contraseña de la cartera virtual
 * @param keyStoreDirectory Dirección de la cartera virtual
 */  
public String getAddress(@NonNull String password, @NonNull File keyStoreDirectory);

/**
 * Devuelve el address de una cartera
 * @param password Contraseña de la cartera virtual
 * @param keyStoreDirectory Dirección de la cartera virtual
 * @return address de la cartera
 */ 
public String getAddress(@NonNull String password, @NonNull String keyStoreDirectory);

/**
 * Devuelve las credenciales
 * @param password Contraseña de la cartera virtual
 * @param keyStoreDirectory Dirección de la cartera virtual
 * @return credenciales de la cartera virtual
 */ 
public Credentials getCredentials(@NonNull String password, @NonNull File keyStoreDirectory);

/**
 * Guarda en el sharedPreferences de android un identificador y la dirección del wallet
 * @param id id para la dirección del wallet
 * @param walletDirectory Dirección de la cartera virtual
 * @param prefsName nombre de las shared preferences que se quiere usar
 * @param activity Actividad de android para poder cargar las shared preferences
 */ 
public void saveInPreferences(@NonNull String id, @NonNull String walletDirectory, @NonNull String prefsName, @NonNull Activity activity);

/**
 * Devuelve el valor asociado al id
 * @param id id del que se quiere su valor
 * @param prefsName nombre de las shared preferences que se quiere usar
 * @param activity Actividad de android para poder cargar las shared preferences
 * @return Devuelve la dirección donde esta guardar la cartera virtual de la persona
 */ 
public String getFromPreferences(@NonNull String id, @NonNull String prefsName, @NonNull Activity activity);
\end{lstlisting}
